<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head next-head"/><title class="next-head">Controlled and uncontrolled input | React patterns and techniques to use in development for React Developers</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" class="next-head"/><meta name="description" content="`${props.title}`" class="next-head"/><meta name="author" content="Bunlong" class="next-head"/><meta property="og:type" content="website" class="next-head"/><meta property="og:url" content="https://reactpatterns.github.io" class="next-head"/><meta property="og:title" content="`${props.title}`" class="next-head"/><meta property="og:image" content="https://reactpatterns.github.io/static/reactjs.png" class="next-head"/><meta property="og:description" content="`${props.title}`" class="next-head"/><link href="../static/styles.css" rel="stylesheet" class="next-head"/><link rel="preload" href="/{reponame}/_next/d9b7326a-a1bc-4581-bac1-4519bc579def/page/post.js" as="script"/><link rel="preload" href="/{reponame}/_next/d9b7326a-a1bc-4581-bac1-4519bc579def/page/_error.js" as="script"/><link rel="preload" href="/{reponame}/_next/d9b7326a-a1bc-4581-bac1-4519bc579def/main.js" as="script"/></head><body><div id="__next"><div data-reactroot=""><div id="container"><div id="about">[ <a href="https://github.com/codefacebook/react-patterns" target="_blank">Github</a> | <a href="https://twitter.com/reactjspatterns" target="_blank">Twitter</a> ]</div><header><h1><a href="/">React Patterns &amp; Techniques</a></h1></header><div><h3>Controlled and uncontrolled input</h3><h4>Uncontrolled input</h4><p>Uncontrolled input is like traditional HTML form input:</p><pre><code>class Form extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre><p>They remember what you typed. You can get their value using a <code>ref</code>. For example, in onClick handler of a button:</p><pre><code>class Form extends Component {
  handleSubmitClick = () =&gt; {
    const name = this._name.value;
    // do something with `name`
  }

  render() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; ref={input =&gt; this._name = input} /&gt;
        &lt;button onClick={this.handleSubmitClick}&gt;Sign up&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre><p>That is the simplest way to implement the form inputs. It’s not as powerful, though, so let’s see the controlled input.</p><h4>Controlled input</h4><p>A controlled input accepts its current value as a prop, as well as a callback to change that value. You could say it’s a &quot;React way&quot;.</p><pre><code>&lt;input value={someValue} onChange={handleChange} /&gt;</code></pre><p>The value of the input has to live in the state somewhere, the component that renders the input (the form component) saves that in its state:</p><pre><code>class Form extends Component {
  constructor() {
    super();
    this.state = {
      name: &#x27;&#x27;
    };
  }

  handleNameChange = (event) =&gt; {
    this.setState({ name: event.target.value });
  };

  render() {
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          value={this.state.name}
          onChange={this.handleNameChange}
        /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre><p>Whenever you type a new character, <code>handleNameChange</code> is called. It takes in the new value of the input and sets it in the state.</p><p><img alt="Controlled input" title="Controlled input" src="https://github.com/codefacebook/react-patterns/blob/master/images/controlled-input-flow.png"/></p><ul><li><p>It starts as an empty string &#x27;&#x27;.</p></li><li><p>You type <code>a</code> and <code>handleNameChange</code> gets an <code>a</code> and calls <code>setState</code>. The input is re-rendered to have the value of <code>a</code>.</p></li><li>You type <code>b</code> and <code>handleNameChange</code> gets the value of <code>ab</code> and sets that to the state. The input is re-rendered once more time, now with value <code>ab</code>.</li></ul><p>Well, This flow kind of pushes the value changes to the form component, so the form component always has the current value of the input, without needing to ask for it.</p><p>It means that your data (state) and UI (inputs) are always in sync. The state gives the value to the input, and the input asks the form to change the current value.</p><hr/><h4>Addition</h4><p>There are many form elements such as checkboxes, radios, selects and textareas.</p><p>A form element becomes &quot;controlled&quot; if you set its value via a <code>prop</code>.</p><p>Each form elements have a different prop for setting that value.</p><table><thead><tr><th style="text-align:left">Element</th><th style="text-align:left">Value Property</th><th style="text-align:left">Change Callback</th><th style="text-align:left">New value in Callback</th></tr></thead><tbody><tr><td style="text-align:left"><code>&lt;input type=&quot;text&quot; /&gt;</code></td><td style="text-align:left">value=&quot;string&quot;</td><td style="text-align:left">onChange</td><td style="text-align:left">event.target.value</td></tr><tr><td style="text-align:left"><code>&lt;input type=&quot;checkbox&quot; /&gt;</code></td><td style="text-align:left">checked={boolean}</td><td style="text-align:left">onChange</td><td style="text-align:left">event.target.checked</td></tr><tr><td style="text-align:left"><code>&lt;input type=&quot;radio&quot; /&gt;</code></td><td style="text-align:left">checked={boolean}</td><td style="text-align:left">onChange</td><td style="text-align:left">event.target.checked</td></tr><tr><td style="text-align:left"><code>&lt;textarea /&gt;</code></td><td style="text-align:left">value=&quot;string&quot;</td><td style="text-align:left">onChange</td><td style="text-align:left">event.target.value</td></tr><tr><td style="text-align:left"><code>&lt;select /&gt;</code></td><td style="text-align:left">value=&quot;option value&quot;</td><td style="text-align:left">onChange</td><td style="text-align:left">event.target.value</td></tr></tbody></table><p>Both the controlled and uncontrolled input have their own merit. Evaluate your specific situation and pick the right one, what works for you is good enough.</p><table><thead><tr><th style="text-align:left">Feature</th><th style="text-align:left">Uncontrolled</th><th style="text-align:left">Controlled</th></tr></thead><tbody><tr><td style="text-align:left">one-time value retrieval (e.g. on submit)</td><td style="text-align:left">:heavy_check_mark:</td><td style="text-align:left">:heavy_check_mark:</td></tr><tr><td style="text-align:left">validating on submit</td><td style="text-align:left">:heavy_check_mark:</td><td style="text-align:left">:heavy_check_mark:</td></tr><tr><td style="text-align:left">instant field validation</td><td style="text-align:left">:x:</td><td style="text-align:left">:heavy_check_mark:</td></tr><tr><td style="text-align:left">conditionally disabling submit button</td><td style="text-align:left">:x:</td><td style="text-align:left">:heavy_check_mark:</td></tr><tr><td style="text-align:left">enforcing input format</td><td style="text-align:left">:x:</td><td style="text-align:left">:heavy_check_mark:</td></tr><tr><td style="text-align:left">several inputs for one piece of data</td><td style="text-align:left">:x:</td><td style="text-align:left">:heavy_check_mark:</td></tr><tr><td style="text-align:left">dynamic inputs</td><td style="text-align:left">:x:</td><td style="text-align:left">:heavy_check_mark:</td></tr></tbody></table></div><footer>© 2018 Maintain by <a href="https://github.com/Bunlong" target="_blank">Bunlong</a> | Website built with <a href="https://reactjs.org" target="_blank">React</a> &amp; <a href="https://github.com/zeit/next.js" target="_blank">Next.js</a></footer></div></div></div><div id="__next-error"></div><script>
          __NEXT_DATA__ = {"props":{"content":"### Controlled and uncontrolled input\n\n#### Uncontrolled input\n\nUncontrolled input is like traditional HTML form input:\n\n```\nclass Form extends Component {\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003cinput type=\"text\" /\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\nThey remember what you typed. You can get their value using a `ref`. For example, in onClick handler of a button:\n\n```\nclass Form extends Component {\n  handleSubmitClick = () =\u003e {\n    const name = this._name.value;\n    // do something with `name`\n  }\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003cinput type=\"text\" ref={input =\u003e this._name = input} /\u003e\n        \u003cbutton onClick={this.handleSubmitClick}\u003eSign up\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\nThat is the simplest way to implement the form inputs. It’s not as powerful, though, so let’s see the controlled input.\n\n#### Controlled input\n\nA controlled input accepts its current value as a prop, as well as a callback to change that value. You could say it’s a \"React way\".\n\n```\n\u003cinput value={someValue} onChange={handleChange} /\u003e\n```\n\nThe value of the input has to live in the state somewhere, the component that renders the input (the form component) saves that in its state:\n\n```\nclass Form extends Component {\n  constructor() {\n    super();\n    this.state = {\n      name: ''\n    };\n  }\n\n  handleNameChange = (event) =\u003e {\n    this.setState({ name: event.target.value });\n  };\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003cinput\n          type=\"text\"\n          value={this.state.name}\n          onChange={this.handleNameChange}\n        /\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\nWhenever you type a new character, `handleNameChange` is called. It takes in the new value of the input and sets it in the state.\n\n![Controlled input](https://github.com/codefacebook/react-patterns/blob/master/images/controlled-input-flow.png \"Controlled input\")\n\n- It starts as an empty string ''.\n\n- You type `a` and `handleNameChange` gets an `a` and calls `setState`. The input is re-rendered to have the value of `a`.\n\n- You type `b` and `handleNameChange` gets the value of `ab` and sets that to the state. The input is re-rendered once more time, now with value `ab`.\n\nWell, This flow kind of pushes the value changes to the form component, so the form component always has the current value of the input, without needing to ask for it.\n\nIt means that your data (state) and UI (inputs) are always in sync. The state gives the value to the input, and the input asks the form to change the current value.\n\n***\n\n#### Addition\n\nThere are many form elements such as checkboxes, radios, selects and textareas.\n\nA form element becomes \"controlled\" if you set its value via a `prop`.\n\nEach form elements have a different prop for setting that value.\n\n| Element                     | Value Property       | Change Callback | New value in Callback  |\n| :-------------------------- | :------------------- | :-------------- | :--------------------- |\n| `\u003cinput type=\"text\" /\u003e`     | value=\"string\"       | onChange        | event.target.value     |\n| `\u003cinput type=\"checkbox\" /\u003e` | checked={boolean}    | onChange        | event.target.checked   |\n| `\u003cinput type=\"radio\" /\u003e`    | checked={boolean}    | onChange        | event.target.checked   |\n| `\u003ctextarea /\u003e`              | value=\"string\"       | onChange        | event.target.value     |\n| `\u003cselect /\u003e`                | value=\"option value\" | onChange        | event.target.value     |\n\nBoth the controlled and uncontrolled input have their own merit. Evaluate your specific situation and pick the right one, what works for you is good enough.\n\n| Feature                                   | Uncontrolled       | Controlled         |\n| :---------------------------------------- | :----------------- | :----------------- |\n| one-time value retrieval (e.g. on submit) | :heavy_check_mark: | :heavy_check_mark: |\n| validating on submit                      | :heavy_check_mark: | :heavy_check_mark: |\n| instant field validation                  | :x:                | :heavy_check_mark: |\n| conditionally disabling submit button     | :x:                | :heavy_check_mark: |\n| enforcing input format                    | :x:                | :heavy_check_mark: |\n| several inputs for one piece of data      | :x:                | :heavy_check_mark: |\n| dynamic inputs                            | :x:                | :heavy_check_mark: |\n","title":"Controlled and uncontrolled input"},"page":"/post","pathname":"/post","query":{"id":"Controlled-and-uncontrolled-input"},"buildId":"d9b7326a-a1bc-4581-bac1-4519bc579def","assetPrefix":"/{reponame}","nextExport":true,"err":null,"chunks":[]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }

          false
        </script><script async="" id="__NEXT_PAGE__/post" src="/{reponame}/_next/d9b7326a-a1bc-4581-bac1-4519bc579def/page/post.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/{reponame}/_next/d9b7326a-a1bc-4581-bac1-4519bc579def/page/_error.js"></script><script src="/{reponame}/_next/d9b7326a-a1bc-4581-bac1-4519bc579def/main.js" async=""></script></body></html>